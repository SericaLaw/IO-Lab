ASSUME DS:DATA, CS:CODE
DATA SEGMENT
    INPUT_STR DB 8 DUP(?)
DATA ENDS

CODE SEGMENT
START:
INIT_DISPLAY:
    MOV AL, 0FFH
    XOR AH, AH
    INT 32H
INIT_REGS:
    LEA SI, INPUT_STR
    XOR BX, BX      
    XOR DX, DX      ; DX:BX STORES THE DISPLAY DATA
    MOV CX, 8       ; USE CX AS LOOP COUNTER
LOOP_READ_INPUT:
    XOR AH, AH
    INT 33H         ; AL STORES THE INPUT
    TEST AL, 10H
    JZ LOOP_READ_INPUT   ; IF THERE IS NO INPUT, THEN KEEP READING
    AND AL, 0FH     ; ELSE, CLEAR STATUS BIT
    MOV [SI], AL    ; SAVE DATA TO MEM
    INC SI
PREPARE_DISPLAY_DATA:
    PUSH CX         ; SAVE LOOP COUNT
    MOV CL, 4       ; SHIFT LEFT DX:BX
    SHL DX, CL
    MOV CH, BH
    SHL BX, CL
    SHR CH, CL
    OR DL, CH
    OR BL, AL       ; SAVE NEW INPUT TO (DX:BX)[3:0]
DISPLAY_INPUT:
    MOV AH, 2
    INT 32H ; DISPLAY A7~A4
    XCHG DX, BX
    DEC AH
    INT 32H ; DISPLAY A3~A0
    XCHG DX, BX
LOOP_CONTROL:
    POP CX
    LOOP LOOP_READ_INPUT    ; END OF LOOP
JUDGE_PALINDROME:
    CALL IS_PALINDROME
OUTPUT_RESULT:
    XOR AH, AH  ; SHOW RESULT ON LED
    INT 30H     ; SHOW RESULT ON LED
    JMP START


IS_PALINDROME PROC
IS_PALINDROME_LOOP_INIT:
    MOV CX, 4
    LEA SI, INPUT_STR   ; SI POINTS TO THE HEAD OF INPUT_STR
    MOV DI, SI  
    ADD DI, 7           ; DI POINTS TO THE TAIL OF INPUT_STR
IS_PALINDROME_LOOP_BODY:
    MOV AL, BYTE PTR[SI]
    CMP AL, BYTE PTR[DI]
    JNZ IS_PALINDROME_FALSE
    INC SI
    DEC DI
    LOOP IS_PALINDROME_LOOP_BODY
IS_PALINDROME_TRUE:
    MOV DX, 0080H   ; IS PALINDROME, LIT GLED7
    RET
IS_PALINDROME_FALSE:
    MOV DX, 8000H   ; IS NOT PALINDROME, LIT YLED7
    RET
IS_PALINDROME ENDP
CODE ENDS
    END START